require 'UniversalDetector'
class String

  def to_url
    str = strip
    # replace whitespace with `-'
    str.gsub!(/(\s+|\_)/, '-')
    str.downcase!
    search_replace = {
                  'Å' => 'a',
                  'Ä' => 'a',
                  'Ö' => 'o',
                  'Ø' => 'o',
                  'Æ' => 'ae',
                  'å' => 'a',
                  'ä' => 'a',
                  'ö' => 'o',
                  'ø' => 'o',
                  'æ' => 'ae',
                  'é' => 'e',
                  'ü' => 'u'}
    search_replace.each{|key, value| str.gsub!( eval( "/" + key + "/") ,value ) }

    # strip all other characters
    str.gsub!(/[^a-z\-0-9]+/, '')
    
    str.gsub!(/\-$/, '')
    str.gsub!(/^\-/, '')
    str.gsub!(/--/,'-')
    str
  end
  
  def to_url!
    replace to_url
  end

  require 'iconv'  
  def to_utf8(from_charset = 'ISO-8859-1')
    c = Iconv.new('UTF-8', from_charset)  
    c.iconv(self) rescue self
  end
  
  def to_latin1(from_charset = 'UTF-8')
    c = Iconv.new('ISO-8859-1', from_charset)  
    c.iconv(self) rescue self
  end

  def to_win_ansi(from_charset = 'UTF-8')
    c = Iconv.new('Windows-1252', from_charset)  
    c.iconv(self)  
  end

end

class Time
  class << self
    # Used for getting multifield attributes like those generated by a 
    # select_datetime into a new Time object. For example if you have 
    # following <tt>params={:meetup=>{:"time(1i)=>..."}}</tt> just do 
    # following:
    #
    # <tt>Time.parse_from_attributes(params[:meetup], :time)</tt>
    def parse_from_attributes(attrs, field, method=:gm)
      attrs = attrs.keys.sort.grep(/^#{field.to_s}\(.+\)$/).map { |k| attrs[k] }
      attrs.any? ? Time.send(method, *attrs) : nil
    end
  end

  def to_delta(delta_type = :day)
    case delta_type
      when :year then self.class.delta(year)
      when :month then self.class.delta(year, month)
      else self.class.delta(year, month, day)
    end
  end
      
  def self.delta(year, month = nil, day = nil)
    from = Time.local(year, month || 1, day || 1)
    to   = if !day.blank?
      from.advance :days => 1
    elsif !month.blank?
      from.advance :months => 1
    else
      from.advance :years => 1
    end
    return [from.midnight, to.midnight-1]
  end
end

class File
  class << self
    # this will not work on unix with windows paths uploaded
    def sanitize_filename(file_name)
      # get only the filename, not the whole path (from IE)
      just_filename = File.basename(file_name) 
      # replace all none alphanumeric, underscore or perioids with underscore
      just_filename.gsub(/[^\w\.\_]/,'_') 
    end
  end
end

module ActsAsFerret
  module ClassMethods
    def paginate_search(query, options = {}, find_options = {})
      options, page, per_page = wp_parse_options!(options)
      pager = WillPaginate::Collection.new(page, per_page, nil)
      options.merge!(:offset => pager.offset, :limit => per_page)
      result = find_by_contents(query, options, find_options)
      returning WillPaginate::Collection.new(page, per_page, result.total_hits) do |pager|
        pager.replace result
      end
    end
  end
end


# Overides the money gem's format method to accept :prefix and :precision rules
class Money
  # Creates a new money object. 
  #  Money.new(100) 
  # 
  # Alternativly you can use the convinience methods like 
  # Money.ca_dollar and Money.us_dollar 
  def initialize(cents, currency = default_currency)
    @cents    = cents.to_f.round
    @currency = currency
  end

  def to_f
    (cents.to_f / 100.00).to_f
  end

  def awesome_format(*rules)
    rules = rules.flatten
    if rules.include?(:no_cents)
      formatted = sprintf("%d", cents.to_f / 100  )          
    else
      formatted = sprintf("%.2f", cents.to_f / 100  )      
    end

    if rules.include?(:with_currency)
      formatted << " "
      formatted << '<span class="currency">' if rules.include?(:html)
      formatted << currency
      formatted << '</span>' if rules.include?(:html)
    end
    formatted
  end

  def round
    to_f.round.to_money
  end
end

class Array
  def in_groups_by
    # Group elements into individual array's by the result of a block
    # Similar to the in_groups_of function.
    # NOTE: assumes array is already ordered/sorted by group !!
    curr=nil.class 
    result=[]
    each do |element|
       group=yield(element) # Get grouping value
       result << [] if curr != group # if not same, start a new array
       curr = group
       result[-1] << element
    end
    result
  end
end

module ActionView
  module Helpers
    module TextHelper      
      # this b ugly hack
      def awesome_cycle(first_value, *values)
        values = values.first if values.first.is_a? Array
        if (values.last.instance_of? Hash)
          params = values.pop
          name = params[:name]
        else
          name = "default"
        end
        values.unshift(first_value)

        cycle = get_cycle(name)
        if (cycle.nil? || cycle.values != values)
          cycle = set_cycle(name, Cycle.new(*values))
        end
        return cycle.to_s
      end
    end
  end
end

module Ultrasphinx
  class Configure  
    class << self

      include Associations
  
      # Force all the indexed models to load and register in the MODEL_CONFIGURATION hash.
      def load_constants
        [PORTHOS_ROOT, "#{RAILS_ROOT}/app/models/"].each do |path|
          Dir.chdir path do
            Dir["**/*.rb"].each do |filename|
              open(filename) do |file| 
                begin
                  if file.grep(/is_indexed/).any?
                    filename = filename[0..-4]
                    begin                
                      File.basename(filename).camelize.constantize
                    rescue NameError => e
                      filename.camelize.constantize
                    end
                  end
                rescue Object => e
                  say "warning: possibly critical autoload error on #{filename}"
                  say e.inspect
                end
              end 
            end
          end
        end
        # Build the field-to-type mappings.
        Fields.instance.configure(MODEL_CONFIGURATION)
      end
    end
  end
end

# Hot fix for not beeing able to resolve file names that includes periods
module Synthesis
  module AssetPackageHelper

    private
      # rewrite compute_public_path to allow us to not include the query string timestamp
      # used by ActionView::Helpers::AssetTagHelper
      def compute_public_path(source, dir, ext = nil, add_asset_id=true)
        source = source.dup
        source << ".#{ext}" if File.extname(source).blank? || (!ext.nil? && File.extname(source) != ext)
        unless source =~ %r{^[-a-z]+://}
          source = "/#{dir}/#{source}" unless source[0] == ?/
          asset_id = rails_asset_id(source)
          source << '?' + asset_id if defined?(RAILS_ROOT) and add_asset_id and not asset_id.blank?
          source = "#{ActionController::Base.asset_host}#{@controller.request.relative_url_root}#{source}"
        end
        source
      end
  
      # rewrite javascript path function to not include query string timestamp
      def javascript_path(source)
        compute_public_path(source, 'javascripts', 'js', false)       
      end

      # rewrite stylesheet path function to not include query string timestamp
      def stylesheet_path(source)
        compute_public_path(source, 'stylesheets', 'css', false)
      end

  end
end